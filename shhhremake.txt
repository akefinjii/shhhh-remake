getgenv().shhhh = {
   General = {
       Notifications = false,
       FOVMode = "PredictionPoint"
   },
   Silent = {
       Main = {
           Enabled = true,
           Mode = "Target",
           Toggle = "C",
           Prediction = 0.12471,
           Parts = {"Head","LowerTorso","UpperTorso"}
       },
       FOV = {
           ShowFOV = false,
           Radius = 70,
           Color = Color3.fromRGB(0, 71, 171),
           Filled = false,
           Transparency = 0.8
       }
   },
   Camlock = {
       Main = {
           Enabled = true,
           Key = "C",
           UnlockKey = "Z",
           SmoothLock = true,
           Smoothness = 0.264,
           PredictMovement = true,
           Prediction = 0.1297,
           Shake = true,
           ShakeValue = 2,
           Parts = {"Head"}
       },
       FOV = {
           UseFOV = true,
           ShowFOV = false,
           Radius = 120,
           Color = Color3.fromRGB(0, 71, 171),
           Filled = false,
           Transparency = 0.4
       }
   },
   Tracer = {
       Enabled = false,
       Color = Color3.fromRGB(137, 207, 240),
       Transparency = 0.4,
       Visible = false
   },
   AutoPrediction = { -- the numbers are pings ( this is for silent + Current sets not recommended )
       Enabled = true,
       ping20_30 = 0.12588,
       ping30_40 = 0.11911,
       ping40_50 = 0.12471,
       ping50_60 = 0.12766,
       ping60_70 = 0.12731,
       ping70_80 = 0.12951,
       ping80_90 = 0.13181,
       ping90_100 = 0.138,
       ping100_110 = 0.146,
       ping110_120 = 0.1367,
       ping120_130 = 0.1401,
       ping130_140 = 0.1437,
       ping140_150 = 0.153,
       ping150_160 = 0.1514,
       ping160_170 = 0.1663,
       ping170_180 = 0.1672,
       ping180_190 = 0.1848,
       ping190_200 = 0.1865,
   }
}

local function getnamecall()
   if game.PlaceId == 2788229376 then
       return "UpdateMousePos"
   elseif game.PlaceId == 5602055394 or game.PlaceId == 7951883376 then
       return "MousePos"
   elseif game.PlaceId == 9825515356 then
       return "GetMousePos"
   end
end

local namecalltype = getnamecall()

function MainEventLocate()
   for _,v in pairs(game:GetService("ReplicatedStorage"):GetDescendants()) do
       if v.Name == "MainEvent" then
           return v
       end
   end
end

local mainevent = MainEventLocate()

-- // Shorthand
local uwushhhh = getgenv().shhhh
local uwuMain = uwushhhh.General
local uwuCamMain = uwushhhh.Camlock.Main
local uwuCamFOV = uwushhhh.Camlock.FOV
local uwuSilentMain = uwushhhh.Silent.Main
local uwuSilentFOV = uwushhhh.Silent.FOV
local uwuTrace = uwushhhh.Tracer
local uwuAutoPred = uwushhhh.AutoPrediction

-- // Optimization
local vect3 = Vector3.new
local vect2 = Vector2.new
local cnew = CFrame.new

-- // Libraries
local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

-- // Services
local uis = game:GetService("UserInputService")
local rs = game:GetService("RunService")
local plrs = game:GetService("Players")
local ws = game:GetService("Workspace")

-- // Script Variables
local CToggle = false
local lplr = plrs.LocalPlayer
local CTarget = nil
local CPart = nil
local SToggle = false
local STarget = nil
local SPart = nil

-- // Client Variables
local m = lplr:GetMouse()
local c = ws.CurrentCamera

-- // Notification Function
local function SendNotification(text)
   Notification:Notify(
       {Title = "shhhh Rewrite", Description = "pl#0001 - "..text},
       {OutlineColor = Color3.fromRGB(50,76,110),Time = 2, Type = "image"},
       {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(50,76,110)}
   )
end 

-- // Call notification function
if uwuMain.Notifications then
   SendNotification("pl#0001 - injecting shhhh Rewrite")
   wait(3.5)
   SendNotification("pl#0001 - finished injecting shhhh Rewrite")
end

-- // Camlock FOV
local CamlockFOV = Drawing.new("Circle")
CamlockFOV.Visible = uwuCamFOV.ShowFOV
CamlockFOV.Thickness = 1
CamlockFOV.NumSides = 30
CamlockFOV.Radius = uwuCamFOV.Radius * 3
CamlockFOV.Color = uwuCamFOV.Color
CamlockFOV.Filled = uwuCamFOV.Filled
CamlockFOV.Transparency = uwuCamFOV.Transparency

--Silent FOV
local SilentFOV = Drawing.new("Circle")
SilentFOV.Visible = uwuSilentFOV.ShowFOV
SilentFOV.Thickness = 1
SilentFOV.NumSides = 30
SilentFOV.Radius = uwuSilentFOV.Radius * 3
SilentFOV.Color = uwuSilentFOV.Color
SilentFOV.Filled = uwuSilentFOV.Filled
SilentFOV.Transparency = uwuSilentFOV.Transparency

--Tracer
local Line = Drawing.new("Line")
Line.Color = uwuTrace.Color
Line.Transparency = uwuTrace.Transparency
Line.Thickness = 1
Line.Visible = uwuTrace.Visible

-- // Script Functions
local function uwuFindTawget() -- // Find target
   local d, t = math.huge, nil
   for _,v in pairs (plrs:GetPlayers()) do
       local _,os = c:WorldToViewportPoint(v.Character.PrimaryPart.Position)
       if v ~= lplr and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") and os then
           local pos = c:WorldToViewportPoint(v.Character.PrimaryPart.Position)
           local magnitude = (vect2(pos.X, pos.Y) - vect2(m.X, m.Y + 36)).magnitude
           if magnitude < d then
               t = v
               d = magnitude
           end
       end
   end
   return t
end

local function uwuFindPart() -- // Find aimpart
   local d, p = math.huge, nil
   if CTarget then
       for _,v in pairs(CTarget.Character:GetChildren()) do
           if table.find(uwuCamMain.Parts, v.Name) then
               local pos = c:WorldToViewportPoint(v.Position)
               local Magn = (vect2(m.X, m.Y + 36) - vect2(pos.X, pos.Y)).Magnitude
               if Magn < d then
                   d = Magn
                   p = v
               end
           end
       end
       return p.Name
   end
end

local function uwuFindSilentPart() -- // Find aimpart
   local d, p = math.huge, nil
   if CTarget then
       for _,v in pairs(CTarget.Character:GetChildren()) do
           if table.find(uwuSilentMain.Parts, v.Name) then
               local pos = c:WorldToViewportPoint(v.Position)
               local Magn = (vect2(m.X, m.Y + 36) - vect2(pos.X, pos.Y)).Magnitude
               if Magn < d then
                   d = Magn
                   p = v
               end
           end
       end
       return p.Name
   end
end

local function uwuCheckAnti(targ) -- // Anti-aim detection
   if (targ.Character.HumanoidRootPart.Velocity.Y < -5 and targ.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall) or targ.Character.HumanoidRootPart.Velocity.Y < -50 then
       return true
   elseif targ and (targ.Character.HumanoidRootPart.Velocity.X > 35 or targ.Character.HumanoidRootPart.Velocity.X < -35) then
       return true
   elseif targ and targ.Character.HumanoidRootPart.Velocity.Y > 60 then
       return true
   elseif targ and (targ.Character.HumanoidRootPart.Velocity.Z > 35 or targ.Character.HumanoidRootPart.Velocity.Z < -35) then
       return true
   else
       return false
   end
end

local function InSilentRadiuwus(target, section, fov) -- // Check if player is in the fov
   if target then
       local pos = nil
       if not uwuCheckAnti(target) then
           pos = c:WorldToViewportPoint(target.Character.PrimaryPart.Position + target.Character.PrimaryPart.Velocity * section.Prediction)
       else
           pos = c:WorldToViewportPoint(target.Character.PrimaryPart.Position + ((target.Character.Humanoid.MoveDirection * target.Character.Humanoid.WalkSpeed) * section.Prediction))
       end
       local mag = (vect2(m.X, m.Y + 36) - vect2(pos.X, pos.Y)).Magnitude
       if mag < fov * 3 then
           return true
       else
           return false
       end
   end
end

local function Silent()
   if STarget then
       if SPart and InSilentRadiuwus(STarget, uwuSilentMain, SilentFOV.Radius) then
           if not uwuCheckAnti(STarget) then
               mainevent:FireServer(namecalltype, STarget.Character[SPart].Position + (STarget.Character[SPart].Velocity * uwuSilentMain.Prediction))
           else
               mainevent:FireServer(namecalltype, STarget.Character[SPart].Position + ((STarget.Character.Humanoid.MoveDirection * STarget.Character.Humanoid.WalkSpeed) * uwuSilentMain.Prediction))
           end
       end
   end
end


local function InRadiuwus(target, section, fov) -- // Check if player is in the fov
   if target then
       if uwuCamFOV.UseFOV then
           local pos = nil
           if not uwuCheckAnti(target) then
               pos = c:WorldToViewportPoint(target.Character.PrimaryPart.Position + target.Character.PrimaryPart.Velocity * section.Prediction)
           else
               pos = c:WorldToViewportPoint(target.Character.PrimaryPart.Position + ((target.Character.Humanoid.MoveDirection * target.Character.Humanoid.WalkSpeed) * section.Prediction))
           end
           local mag = (vect2(m.X, m.Y + 36) - vect2(pos.X, pos.Y)).Magnitude
           if mag < fov * 3 then
               return true
           else
               return false
           end
       else
           return true
       end
   end
end

uis.InputBegan:Connect(function(k,t)
   if not t then
       if k.KeyCode == Enum.KeyCode[uwuCamMain.Key:upper()] then
           CToggle = true
           CTarget = uwuFindTawget()
           if uwuMain.Notifications then
               SendNotification("locked onto "..CTarget.Name)
           end
       elseif k.KeyCode == Enum.KeyCode[uwuCamMain.UnlockKey:upper()] then
           if CToggle then
               CToggle = false
               CTarget = nil
               if uwuMain.Notifications then
                   SendNotification("unlocked")
               end
           end
       elseif k.KeyCode == Enum.KeyCode[uwuSilentMain.Toggle:upper()] and uwuSilentMain == "Regular" then
           if SToggle then
               SToggle = false
               if uwuMain.Notifications then
                   SendNotification("silent disabled")
               end
           else
               SToggle = true
               if uwuMain.Notifications then
                   SendNotification("silent enabled")
               end
           end
       end
   end
end)

rs.RenderStepped:Connect(function()
   if CTarget then
       CPart = uwuFindPart()
       local pos = nil
       local cum = nil
       if CTarget.Character.BodyEffects["K.O"].Value == true or lplr.Character.BodyEffects["K.O"].Value == true then
           CToggle = false
           CTarget = nil
       else
           if uwuCamMain.Shake then
               if uwuCamMain.PredictMovement then
                   if not uwuCheckAnti(CTarget) then
                       cum = CTarget.Character[CPart].Position + CTarget.Character[CPart].Velocity * uwuCamMain.Prediction + (vect3(
                           math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue),
                           math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue),
                           math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue)
                       ) * 0.1)
                   else
                       cum = CTarget.Character[CPart].Position + ((CTarget.Character.Humanoid.MoveDirection * CTarget.Character.Humanoid.WalkSpeed) * uwuCamMain.Prediction + (vect3(
                           math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue),
                           math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue),
                           math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue)
                       ) * 0.1))
                   end
                   pos = c:WorldToViewportPoint(cum)
               else
                   cum = CTarget.Character[CPart].Position + (vect3(
                       math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue),
                       math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue),
                       math.random(-uwuCamMain.ShakeValue, uwuCamMain.ShakeValue)
                   ) * 0.1)
                   pos = c:WorldToViewportPoint(cum)
               end
           else
               if uwuCamMain.PredictMovement then
                   if not uwuCheckAnti(CTarget) then
                       cum = CTarget.Character[CPart].Position + CTarget.Character[CPart].Velocity * uwuCamMain.Prediction
                   else
                       cum = CTarget.Character[CPart].Position + ((CTarget.Character.Humanoid.MoveDirection * CTarget.Character.Humanoid.WalkSpeed) * uwuCamMain.Prediction)
                   end
                   pos = c:WorldToViewportPoint(cum)
               else
                   cum = CTarget.Character[CPart].Position
                   pos = c:WorldToViewportPoint(cum)
               end
           end
           if InRadiuwus(CTarget, uwuCamMain, CamlockFOV.Radius) then
               local main = nil
               if uwuCamMain.SmoothLock then
                   main = cnew(c.CFrame.p, cum)
                   c.CFrame = c.CFrame:Lerp(main, uwuCamMain.Smoothness, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
               else
                   c.CFrame = cnew(c.CFrame.p, cum)
               end
           end
           if uwuMain.FOVMode == "Mouse" then
               if uwuCamFOV.ShowFOV then
                   CamlockFOV.Position = vect2(m.X, m.Y + 36)
               end
               if uwuSilentFOV.ShowFOV then
                   SilentFOV.Position = vect2(m.X, m.Y + 36)
               end
           elseif uwuMain.FOVMode == "PredictionPoint" then
               if uwuCamFOV.ShowFOV then
                   CamlockFOV.Position = vect2(pos.X, pos.Y)
               end
               if uwuSilentFOV.ShowFOV then
                   SilentFOV.Position = vect2(pos.X, pos.Y)
               end
           end
           if uwuTrace.Enabled then
               Line.Visible = true
               Line.From = vect2(m.X, m.Y + 36)
               Line.To = vect2(pos.X, pos.Y)
           end
       end
   else
       CamlockFOV.Position = vect2(m.X, m.Y + 36)
       SilentFOV.Position = vect2(m.X, m.Y + 36)
       Line.Visible = false
   end
end)

lplr.Character.ChildAdded:Connect(function(tool)
   if tool:IsA("Tool") then
       tool.Activated:connect(function()
           if uwuSilentMain.Mode == "Regular" then
               if SToggle then
                   STarget = uwuFindTawget()
                   if STarget then
                       SPart = uwuFindSilentPart()
                       if SPart then
                           Silent()
                       end
                   end
               end
           elseif uwuSilentMain.Mode == "Target" then
               if CToggle then
                   STarget = CTarget
                   if STarget then
                       SPart = uwuFindSilentPart()
                       if SPart then
                           Silent()
                       end
                   end
               end
           end
       end)
   end
end)

lplr.CharacterAdded:Connect(function(char)
   char.ChildAdded:Connect(function(tool)
       tool.Activated:connect(function()
           if uwuSilentMain.Mode == "Regular" then
               if SToggle then
                   STarget = uwuFindTawget()
                   if STarget then
                       SPart = uwuFindSilentPart()
                       if SPart then
                           Silent()
                       end
                   end
               end
           elseif uwuSilentMain.Mode == "Target" then
               if CToggle then
                   STarget = CTarget
                   if STarget then
                       SPart = uwuFindSilentPart()
                       if SPart then
                           Silent()
                       end
                   end
               end
           end
       end)
   end)
end)

--Auto Prediction
coroutine.resume(coroutine.create(function()
   while true do
       if uwuAutoPred.Enabled then
           local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
           if ping <= 40 then
               uwuSilentMain.Prediction = uwuAutoPred.ping30_40
           elseif ping <= 50 then
               uwuSilentMain.Prediction = uwuAutoPred.ping40_50
           elseif ping <= 60 then
               uwuSilentMain.Prediction = uwuAutoPred.ping50_60
           elseif ping <= 70 then
               uwuSilentMain.Prediction = uwuAutoPred.ping60_70
           elseif ping <= 80 then
               uwuSilentMain.Prediction = uwuAutoPred.ping70_80
           elseif ping <= 90 then
               uwuSilentMain.Prediction = uwuAutoPred.ping80_90
           elseif ping <= 100 then
               uwuSilentMain.Prediction = uwuAutoPred.ping90_100
           elseif ping <= 110 then
               uwuSilentMain.Prediction = uwuAutoPred.ping100_110
           elseif ping <= 120 then
               uwuSilentMain.Prediction = uwuAutoPred.ping110_120
           elseif ping <= 130 then
               uwuSilentMain.Prediction = uwuAutoPred.ping120_130
           elseif ping <= 140 then
               uwuSilentMain.Prediction = uwuAutoPred.ping130_140
           elseif ping <= 150 then
               uwuSilentMain.Prediction = uwuAutoPred.ping140_150
           elseif ping <= 160 then
               uwuSilentMain.Prediction = uwuAutoPred.ping150_160
           elseif ping <= 170 then
               uwuSilentMain.Prediction = uwuAutoPred.ping160_170
           elseif ping <= 180 then
               uwuSilentMain.Prediction = uwuAutoPred.ping170_180
           elseif ping <= 190 then
               uwuSilentMain.Prediction = uwuAutoPred.ping180_190
           elseif ping <= 200 then
               uwuSilentMain.Prediction = uwuAutoPred.ping190_200
           end
           task.wait(0.7)
       end
   end
end))


getgenv().shhhh = {
        ["Main"] = {
            ["Intro"] = true,
            ["UI"] = true,
            ["Keybind"] = "P",
            ["Visible Text"] = false
        },
        ["Triggerbot"] = {
            ["Enabled"] = true,
            ["Key"] = "T",
            ["Toggle"] = true,
            ["Hold"] = false,
            ["Delay"] = 0.1,
            ["Distance"] = 150,
            ["CheckTeam"] = false,
            ["CheckKnocked"] = true,
            ["VisibilityCheck"] = true
        },
        ["UITitle"] = {
            ["Text"] = "shhhh",
            ["Extension"] = {
                ["Fringe"] = "[",
                ["End"] = "]"
            },
            ["Size"] = 13
        },
        ["Size"] = {
            ["X"] = 10 * 10,
            ["Y"] = 10 * 1
        },
        ["Color"] = {
            ["Inline"] = Color3.fromRGB(255,255,255),
            ["Outline"] = Color3.fromRGB(0, 0, 0)
        },
        ["Fade Speed"] = {
            ["Intro"] = 0.1,
            ["Outro"] = 0.01
        },
        ["Misc"] = {
            ["Check"] = {
                ["TeamCheck"] = false,
                ["PlayerKnockCheck"] = true,
                ["VisCheck"] = true,
                ["Resolver"] = false
            },
            ["FOV"] = {
                ["Esp"] = {
                    ["Enabled"] = true,
                    ["Keybind"] = "T",
                    ["Radius"] = 700,
                    ["Style"] = "Circle",
                    ["BoxSize"] = {
                        ["X"] = 500,
                        ["Y"] = 500
                    },
                    ["Inline"] = {
                        ["Transparency"] = 0.4,
                        ["Color"] = Color3.fromRGB(255, 255, 255)
                    },
                    ["Outline"] = {
                        ["Transparency"] = 0.65,
                        ["Color"] = Color3.fromRGB(255, 255, 255)
                    },
                    ["Control"] = {
                        ["Stick To Target"] = false,
                        ["ShowClosestPoint"] = true
                    }
                }
            }
        },
        ["Aimbot"] = {
            ["Panel"] = {
                ["Enabled"] = true,
                ["Keybind"] = {
                    ["Enabled"] = "F",
                    ["Disabled"] = "G"
                },
                Key = 'C',
                ["HitPart"] = {
                    ["Target"] = "HumanoidRootPart",
                    ["Revaluate"] = {
                        ["Enabled"] = false,
                        ["Origin"] = "Humanoid"
                    }
                },
                ["Prediction"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 10
                },
                ["Assist"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 40
                },
                ["Panel"] = {
                    ["Method"] = "Camera",
                    ["Target"] = false,
                    ["Lerp"] = {
                        ["Type"] = "Linear",
                        ["Direction"] = "In"
                    }
                }
            }
        },
        ["Silent"] = {
            ["Redirection"] = {
                ["Info"] = {
                    ["Enabled"] = true,
                    ["Keybind"] = "E"
                },
                ["Extension"] = {
                    ["Fringe"] = "[",
                    ["End"] = "]"
                },
                ["HitPart"] = {
                    ["Target"] = "Head",
                    ["Revaluate"] = {
                        ["Enabled"] = true,
                        ["Origin"] = "Humanoid"
                    },
                    ["Validated Part"] = {"HumanoidRootPart", "Head"}
                },
                ["HitChance"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 100
                },
                ["Prediction"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 0
                }, 
                ["AntiCurve"] = {
                    ["Enabled"] = true,
                    ["X"] = 0,
                    ["Y"] = 0,
                    ["Z"] = 0
                },
                ["Visualizetarget"] = {
                    ["Enabled"] = true,
                    ["Tracer"] = {
                        ["Enabled"] = true,
                        ["Key"] = "Y",
                        ["Color"] = Color3.fromRGB(255, 255, 255),
                        ["Thickness"] = 1,
                        ["Transparency"] = 1
                    }
                }
            }
        },
        ["WalkSpeed"] = {
            ["Options"] = {
                ["Enabled"] = true,
                ["Speed"] = 500,
                ["Keybind"] = "X",
                ["AutoEmote"] = false,
                ["EmoteDelay"] = 0.15,
                ["EmoteKey"] = "Period",
                ["EmoteSlot"] = "1"
            }
        },
        ["Camlock"] = {
            ["Enabled"] = false,
            ["Key"] = "Q",
            ["Toggle"] = true,
            ["Prediction"] = {
                ["Enabled"] = true,
                ["Amount"] = 0.135
            },
            ["Smoothness"] = {
                ["Enabled"] = true,
                ["Amount"] = 0.055
            },
            ["HitPart"] = "HumanoidRootPart",
            ["Shake"] = {
                ["Enabled"] = true,
                ["X"] = 3,
                ["Y"] = 3,
                ["Z"] = 3
            },
            ["AimAssist"] = {
                ["Enabled"] = true,
                ["Strength"] = 0.35,
                ["SlowSensitivity"] = true,
                ["SlowAmount"] = 0.5
            }
        },
    }
    if not LPH_OBFUSCATED then
        LPH_JIT_MAX = function(...)
            return (...)
        end
        LPH_JIT_ULTRA = function(...)
            return (...)
        end
    end


    LPH_JIT_MAX(
        function()
            local Drawing, FromRGB = Drawing.new, Color3.fromRGB
            local UIS, Players, MPS, RunService, Camera, Tween =
                game:GetService("UserInputService"),
                game:GetService("Players"),
                game:GetService("MarketplaceService"),
                game:GetService("RunService"),
                game:GetService("Workspace").CurrentCamera,
                {}
            function Direction(Value, Two)
                return Vector2.new(Value / shhhh["Size"].X, Two / shhhh["Size"].Y)
            end
            local cam = workspace.CurrentCamera
            local x = cam.ViewportSize.X
            local y = cam.ViewportSize.Y
            local newx = math.floor(x * 0.51)
            local newy = math.floor(y * 0.44)
            local Title = Drawing("Text")
            local Value = Drawing("Text")
            local Part = Drawing("Text")
            if shhhh["Main"]["Intro"] == true then
                -- Create the intro GUI
                local Intro = Instance.new("ScreenGui")
                Intro.Name = "QuietIntro"
                Intro.Parent = game.CoreGui
                
                -- Create background frame
                local Background = Instance.new("Frame")
                Background.Size = UDim2.new(1, 0, 1, 0)
                Background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                Background.BackgroundTransparency = 0
                Background.Parent = Intro
                
                -- Create stick figures container
                local StickFigures = Instance.new("Frame")
                StickFigures.Size = UDim2.new(0.4, 0, 0.4, 0)
                StickFigures.Position = UDim2.new(0.3, 0, 0.3, 0)
                StickFigures.BackgroundTransparency = 1
                StickFigures.Parent = Background
                
                -- Function to create a stick figure
                local function CreateStickFigure(position, color)
                    local container = Instance.new("Frame")
                    container.Size = UDim2.new(0.15, 0, 0.4, 0)
                    container.Position = position
                    container.BackgroundTransparency = 1
                    container.Parent = StickFigures

                    -- Head
                    local head = Instance.new("Frame")
                    head.Size = UDim2.new(0.2, 0, 0.2, 0)
                    head.Position = UDim2.new(0.4, 0, 0, 0)
                    head.BackgroundColor3 = color
                    head.Parent = container

                    -- Body
                    local body = Instance.new("Frame")
                    body.Size = UDim2.new(0.1, 0, 0.4, 0)
                    body.Position = UDim2.new(0.45, 0, 0.2, 0)
                    body.BackgroundColor3 = color
                    body.Parent = container

                    -- Arms
                    local leftArm = Instance.new("Frame")
                    leftArm.Size = UDim2.new(0.3, 0, 0.1, 0)
                    leftArm.Position = UDim2.new(0.15, 0, 0.25, 0)
                    leftArm.BackgroundColor3 = color
                    leftArm.Parent = container

                    local rightArm = Instance.new("Frame")
                    rightArm.Size = UDim2.new(0.3, 0, 0.1, 0)
                    rightArm.Position = UDim2.new(0.55, 0, 0.25, 0)
                    rightArm.BackgroundColor3 = color
                    rightArm.Parent = container

                    -- Legs
                    local leftLeg = Instance.new("Frame")
                    leftLeg.Size = UDim2.new(0.1, 0, 0.3, 0)
                    leftLeg.Position = UDim2.new(0.35, 0, 0.6, 0)
                    leftLeg.BackgroundColor3 = color
                    leftLeg.Parent = container

                    local rightLeg = Instance.new("Frame")
                    rightLeg.Size = UDim2.new(0.1, 0, 0.3, 0)
                    rightLeg.Position = UDim2.new(0.55, 0, 0.6, 0)
                    rightLeg.BackgroundColor3 = color
                    rightLeg.Parent = container

                    return container
                end

                -- Create stick figures
                local StickFigure1 = CreateStickFigure(UDim2.new(0.1, 0, 0.3, 0), Color3.fromRGB(255,255,255))
                local StickFigure2 = CreateStickFigure(UDim2.new(0.6, 0, 0.3, 0), Color3.fromRGB(255, 255, 255))

                -- Add weapon effects
                local function CreateWeaponEffect(parent, side)
                    local weapon = Instance.new("Frame")
                    weapon.Size = UDim2.new(0.4, 0, 0.05, 0)
                    weapon.Position = UDim2.new(side == "left" and -0.2 or 0.8, 0, 0.25, 0)
                    weapon.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                    weapon.Parent = parent
                    return weapon
                end

                local weapon1 = CreateWeaponEffect(StickFigure1, "right")
                local weapon2 = CreateWeaponEffect(StickFigure2, "left")

                -- Add glow effects
                local function CreateGlow(parent)
                    local glow = Instance.new("ImageLabel")
                    glow.Size = UDim2.new(2, 0, 2, 0)
                    glow.Position = UDim2.new(-0.5, 0, -0.5, 0)
                    glow.BackgroundTransparency = 1
                    glow.Image = "rbxassetid://131274595"
                    glow.ImageColor3 = parent.BackgroundColor3
                    glow.ImageTransparency = 0.8
                    glow.Parent = parent
                    return glow
                end

                -- Add glows to weapons
                CreateGlow(weapon1)
                CreateGlow(weapon2)
                
                -- Create logo text
                local LogoText = Instance.new("TextLabel")
                LogoText.Size = UDim2.new(0.5, 0, 0.1, 0)
                LogoText.Position = UDim2.new(0.25, 0, 0.8, 0)
                LogoText.BackgroundTransparency = 1
                LogoText.Text = "shhhh"
                LogoText.TextColor3 = Color3.fromRGB(255,255,255)
                LogoText.TextSize = 48
                LogoText.Font = Enum.Font.GothamBold
                LogoText.Parent = Background
                
                -- Create discord text
                local DiscordText = Instance.new("TextLabel")
                DiscordText.Size = UDim2.new(0.5, 0, 0.05, 0)
                DiscordText.Position = UDim2.new(0.25, 0, 0.9, 0)
                DiscordText.BackgroundTransparency = 1
                DiscordText.Text = "nigger"
                DiscordText.TextColor3 = Color3.fromRGB(255, 255, 255)
                DiscordText.TextSize = 24
                DiscordText.Font = Enum.Font.Gotham
                DiscordText.Parent = Background
                DiscordText.TextTransparency = 1
                
                -- Play roar sound
                local RoarSound = Instance.new("Sound")
                RoarSound.SoundId = "rbxassetid://6545997667" -- Epic roar sound
                RoarSound.Volume = 0.5
                RoarSound.Parent = game.CoreGui
                RoarSound:Play()
                
                -- Animate stick figures
                local TweenService = game:GetService("TweenService")
                
                -- Create hit effect
                local function CreateHitEffect(position)
                    local effect = Instance.new("ImageLabel")
                    effect.Size = UDim2.new(0.2, 0, 0.2, 0)
                    effect.Position = position
                    effect.BackgroundTransparency = 1
                    effect.Image = "rbxassetid://446111271"  -- Explosion effect
                    effect.ImageColor3 = Color3.fromRGB(255, 0, 0)
                    effect.ImageTransparency = 0
                    effect.Parent = Background
                    
                    -- Animate the hit effect
                    TweenService:Create(effect, TweenInfo.new(0.3), {
                        Size = UDim2.new(0.4, 0, 0.4, 0),
                        ImageTransparency = 1
                    }):Play()
                    
                    task.delay(0.3, function()
                        effect:Destroy()
                    end)
                end

                -- Fight animation sequence
                task.spawn(function()
                    -- Initial pause
                    task.wait(0.5)

                    for i = 1, 2 do
                        -- Figure 1 attack sequence
                        TweenService:Create(StickFigure1, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.3, 0, 0.3, 0),
                            Rotation = 15
                        }):Play()
                        
                        task.wait(0.1)
                        CreateHitEffect(UDim2.new(0.45, 0, 0.4, 0))
                        
                        -- Weapon flash effect
                        TweenService:Create(weapon1, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                        }):Play()
                        
                        task.wait(0.1)
                        TweenService:Create(StickFigure1, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.1, 0, 0.3, 0),
                            Rotation = 0
                        }):Play()
                        
                        TweenService:Create(weapon1, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        }):Play()

                        -- Figure 2 attack sequence
                        task.wait(0.3)
                        TweenService:Create(StickFigure2, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.4, 0, 0.3, 0),
                            Rotation = -15
                        }):Play()
                        
                        task.wait(0.1)
                        CreateHitEffect(UDim2.new(0.25, 0, 0.4, 0))
                        
                        -- Weapon flash effect
                        TweenService:Create(weapon2, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                        }):Play()
                        
                        task.wait(0.1)
                        TweenService:Create(StickFigure2, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.6, 0, 0.3, 0),
                            Rotation = 0
                        }):Play()
                        
                        TweenService:Create(weapon2, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        }):Play()
                        
                        task.wait(0.3)
                    end

                    -- Final clash
                    TweenService:Create(StickFigure1, TweenInfo.new(0.3), {
                        Position = UDim2.new(0.35, 0, 0.3, 0),
                        Rotation = 30
                    }):Play()
                    
                    TweenService:Create(StickFigure2, TweenInfo.new(0.3), {
                        Position = UDim2.new(0.35, 0, 0.3, 0),
                        Rotation = -30
                    }):Play()
                    
                    task.wait(0.3)
                    CreateHitEffect(UDim2.new(0.35, 0, 0.4, 0))
                    
                    -- Big flash effect
                    local flash = Instance.new("Frame")
                    flash.Size = UDim2.new(1, 0, 1, 0)
                    flash.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    flash.BackgroundTransparency = 0
                    flash.Parent = Background
                    
                    TweenService:Create(flash, TweenInfo.new(0.5), {
                        BackgroundTransparency = 1
                    }):Play()
                    
                    task.wait(0.5)
                    flash:Destroy()
                end)
                
                -- Fade in logo and discord text
                task.wait(0.5)
                TweenService:Create(LogoText, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
                task.wait(0.3)
                TweenService:Create(DiscordText, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
                
                -- Hold the animation
                task.wait(2)
                
                -- Fade out everything
                TweenService:Create(Background, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
                TweenService:Create(StickFigure1, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
                TweenService:Create(StickFigure2, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
                TweenService:Create(LogoText, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
                TweenService:Create(DiscordText, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
                
                -- Clean up
                task.wait(0.5)
                Intro:Destroy()
                RoarSound:Destroy()
            end
            wait(0.15)

            local function Table()
                local hitparts = shhhh.Silent.Redirection["HitPart"]["Validated Parts"]

                Title.Position, Title.Size =
                    Direction(Camera.ViewportSize.X + 800, Camera.ViewportSize.Y),
                    shhhh["UITitle"].Size
                Value.Position, Value.Size =
                    Direction(Camera.ViewportSize.X, Camera.ViewportSize.Y + 400),
                    shhhh["UITitle"].Size
                Part.Position, Part.Size =
                    Direction(Camera.ViewportSize.X + 800, Camera.ViewportSize.Y + 600),
                    shhhh["UITitle"].Size

                if shhhh["Main"]["UI"] then
                    Title.Text, Title.Font =
                        tostring(
                            shhhh["UITitle"].Text ..
                                " " ..
                                    shhhh["UITitle"].Extension.Fringe ..
                                        game.Stats.Workspace.Heartbeat:GetValueString() .. shhhh["UITitle"].Extension.End
                        ),
                        2
                    Title.Visible, Title.Outline, Title.Color, Title.OutlineColor =
                        shhhh["Main"]["Visible Text"],
                        true,
                        shhhh["Color"].Inline,
                        shhhh["Color"].Outline

                    Value.Font, Value.Visible, Value.Inline, Value.Color, Value.OutlineColor =
                        2,
                        shhhh["Main"]["Visible Text"],
                        true,
                        shhhh.Silent.Redirection,
                        shhhh["Color"].Inline

                    Part.Font, Part.Visible, Part.Inline, Part.Color, Part.OutlineColor =
                        2,
                        shhhh["Main"]["Visible Text"],
                        true,
                        shhhh.Silent.Redirection,
                        shhhh["Color"].Inline

                    if shhhh.Silent.Redirection["Info"].Enabled then
                        Value.Text = "   " .. "Silent" .. " = " .. "On"
                        Part.Text = tostring("HitPart" .." = " .. (shhhh.Silent["Redirection"]["HitPart"]["Target"]):lower())
                        
                        if isSpeedEnabled and enable then
                            Part.Text = Part.Text .. "\n   Speed = " .. tostring(getgenv().shhhh.WalkSpeed.Options.DefaultSpeed)
                        end
                    else
                        Part.Text = ""
                        Value.Text = "   " .. "Silent" .. " = " .. "Off"
                        
                        if isSpeedEnabled and enable then
                            Part.Text = "   Speed = " .. tostring(getgenv().shhhh.WalkSpeed.Options.DefaultSpeed)
                        end
                    end
                else
                end
            end

            local Utilitie = {}
            Utilitie.Toggle = false

            UIS.InputBegan:Connect(
                function(Two, Input)
                    if not Input then
                        if Two.KeyCode.Name == shhhh["Main"]["Keybind"] then
                            Utilitie.Toggle = not Utilitie.Toggle
                            if Utilitie.Toggle then
                                RunService:BindToRenderStep("Table!", 1, Table)
                                for i = 0, 1, shhhh["Fade Speed"].Intro do
                                    wait(0)
                                    Title.Transparency = i
                                    Value.Transparency = i
                                    Part.Transparency = i
                                end

                                shhhh["Main"]["UI"] = true
                                shhhh["Main"]["Visible Text"] = true
                            elseif not Utilitie.Toggle then
                                RunService:UnbindFromRenderStep("Table")
                                shhhh["Main"]["UI"] = false

                                Title.Transparency = 0.9
                                Value.Transparency = 0.9
                                Part.Transparency = 0.9
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.8
                                Value.Transparency = 0.8
                                Part.Transparency = 0.8
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.7
                                Value.Transparency = 0.7
                                Part.Transparency = 0.7
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.6
                                Value.Transparency = 0.6
                                Part.Transparency = 0.6
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.5
                                Value.Transparency = 0.5
                                Part.Transparency = 0.5
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.4
                                Value.Transparency = 0.4
                                Part.Transparency = 0.4
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.3
                                Value.Transparency = 0.3
                                Part.Transparency = 0.3
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.2
                                Value.Transparency = 0.2
                                Part.Transparency = 0.2
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.1
                                Value.Transparency = 0.1
                                Part.Transparency = 0.1
                                wait(shhhh["Fade Speed"].Outro)
                                Title.Transparency = 0.1
                                Value.Transparency = 0.1
                                Part.Transparency = 0.1
                                wait(shhhh["Fade Speed"].Outro)

                                Title.Transparency = 0
                                Value.Transparency = 0
                                Part.Transparency = 0
                            end
                        end
                    end
                end
            )

            WTS = (function(Object)
                local ObjectVector = Camera:WorldToScreenPoint(Object.Position)
                return Vector2.new(ObjectVector.X, ObjectVector.Y)
            end)

            local FOV = {}
            FOV.MouseLink = Drawing("Circle")
            FOV.ClosestPoint = Drawing("Circle")
            FOV.Line = Drawing("Line")
            FOV.LineOutline = Drawing("Line")
            
            -- Create both circle and box FOV elements
            FOV.Circle = {
                Outline = Drawing("Circle"),
                Inline = Drawing("Circle")
            }
            
            FOV.Box = {
                Outline = Drawing("Square"),
                Inline = Drawing("Square")
            }
            
            -- Initialize Line objects
            FOV.Line.Thickness = 3
            FOV.Line.Transparency = 0.8
            FOV.Line.Color = Color3.fromRGB(255, 255, 255)
            FOV.Line.Visible = false

            FOV.LineOutline.Thickness = 7
            FOV.LineOutline.Transparency = 0.4
            FOV.LineOutline.Color = Color3.fromRGB(255, 255, 255)
            FOV.LineOutline.Visible = false
            
            -- Initialize closest point indicator
            FOV.ClosestPoint.Radius = 4
            FOV.ClosestPoint.Filled = true
            FOV.ClosestPoint.Transparency = 1
            FOV.ClosestPoint.Color = Color3.fromRGB(255, 0, 0)
            FOV.ClosestPoint.Visible = false

            -- Initialize MouseLink
            FOV.MouseLink.Radius = 20
            FOV.MouseLink.Thickness = 0.4
            FOV.MouseLink.Filled = false
            FOV.MouseLink.Transparency = 1
            FOV.MouseLink.Color = Color3.fromRGB(255, 255, 255)
            FOV.MouseLink.Visible = false

            -- Initialize Circle FOV
            FOV.Circle.Inline.Visible = false
            FOV.Circle.Inline.Radius = shhhh.Misc.FOV.Esp.Radius
            FOV.Circle.Inline.Transparency = shhhh.Misc.FOV.Esp.Inline.Transparency
            FOV.Circle.Inline.Color = shhhh.Misc.FOV.Esp.Inline.Color
            FOV.Circle.Inline.Thickness = 3
            FOV.Circle.Inline.Filled = true

            FOV.Circle.Outline.Visible = false
            FOV.Circle.Outline.Radius = shhhh.Misc.FOV.Esp.Radius
            FOV.Circle.Outline.Transparency = shhhh.Misc.FOV.Esp.Outline.Transparency
            FOV.Circle.Outline.Color = shhhh.Misc.FOV.Esp.Outline.Color
            FOV.Circle.Outline.Thickness = 4
            FOV.Circle.Outline.Filled = false

            -- Initialize Box FOV
            FOV.Box.Inline.Visible = false
            FOV.Box.Inline.Size = Vector2.new(shhhh.Misc.FOV.Esp.BoxSize.X, shhhh.Misc.FOV.Esp.BoxSize.Y)
            FOV.Box.Inline.Transparency = shhhh.Misc.FOV.Esp.Inline.Transparency
            FOV.Box.Inline.Color = shhhh.Misc.FOV.Esp.Inline.Color
            FOV.Box.Inline.Thickness = 3
            FOV.Box.Inline.Filled = true

            FOV.Box.Outline.Visible = false
            FOV.Box.Outline.Size = Vector2.new(shhhh.Misc.FOV.Esp.BoxSize.X, shhhh.Misc.FOV.Esp.BoxSize.Y)
            FOV.Box.Outline.Transparency = shhhh.Misc.FOV.Esp.Outline.Transparency
            FOV.Box.Outline.Color = shhhh.Misc.FOV.Esp.Outline.Color
            FOV.Box.Outline.Thickness = 4
            FOV.Box.Outline.Filled = false

            -- Function to update FOV position
            local function UpdateFOVPosition(position)
                if shhhh.Misc.FOV.Esp.Style == "Circle" then
                    FOV.Circle.Inline.Position = position
                    FOV.Circle.Outline.Position = position
                    FOV.Circle.Inline.Visible = shhhh.Misc.FOV.Esp.Enabled
                    FOV.Circle.Outline.Visible = shhhh.Misc.FOV.Esp.Enabled
                    FOV.Box.Inline.Visible = false
                    FOV.Box.Outline.Visible = false
                else
                    FOV.Box.Inline.Position = position - (FOV.Box.Inline.Size / 2)
                    FOV.Box.Outline.Position = position - (FOV.Box.Outline.Size / 2)
                    FOV.Box.Inline.Visible = shhhh.Misc.FOV.Esp.Enabled
                    FOV.Box.Outline.Visible = shhhh.Misc.FOV.Esp.Enabled
                    FOV.Circle.Inline.Visible = false
                    FOV.Circle.Outline.Visible = false
                end
            end

            -- Function to get closest point on FOV
            local function GetClosestPointOnFOV(center, target)
                if shhhh.Misc.FOV.Esp.Style == "Circle" then
                    local direction = (target - center).Unit
                    return center + direction * FOV.Circle.Inline.Radius
                else
                    local halfSize = FOV.Box.Inline.Size / 2
                    local relative = target - center
                    local clamped = Vector2.new(
                        math.clamp(relative.X, -halfSize.X, halfSize.X),
                        math.clamp(relative.Y, -halfSize.Y, halfSize.Y)
                    )
                    return center + clamped
                end
            end

            local GameInfo = game.PlaceId

            local LocalPlayer = Players.LocalPlayer
            local Mouse = LocalPlayer:GetMouse()

            local IgnoreList = {LocalPlayer.Character, Camera}
            local StickyTarget = nil  -- Add sticky target variable

            local function PartVisible(Part)
                if shhhh.Misc.Check["VisCheck"] and Part and Part.Head then
                    local Hit =
                        workspace:FindPartOnRayWithIgnoreList(
                        Ray.new(Camera.CFrame.Position, Part.Head.Position - Camera.CFrame.Position),
                        IgnoreList
                    )
                    if Hit and Hit:IsDescendantOf(Part) then
                        return true
                    end
                    return false
                else
                    return true
                end
            end

            function ClosestToCursor()
                -- If we have a valid sticky target, keep using it
                if StickyTarget and StickyTarget.Character and StickyTarget.Character:FindFirstChild("HumanoidRootPart") and
                    (shhhh.Misc["Check"]["TeamCheck"] == true and (StickyTarget.Team ~= LocalPlayer.Team) or
                        shhhh.Misc["Check"]["TeamCheck"] ~= true)
                then
                    local MouseLocation = UIS:GetMouseLocation()
                    local Vector, IsVisible = Camera:WorldToViewportPoint(StickyTarget.Character.HumanoidRootPart.Position)
                    
                    -- Only check if target is still visible and valid
                    if IsVisible and PartVisible(StickyTarget.Character) then
                        return StickyTarget
                    end
                end

                -- Only find new target if we don't have a sticky target
                if not StickyTarget then
                local Closest = nil
                    local Distance = FOV.Circle.Inline.Radius
                for i, v in pairs(Players:GetPlayers()) do
                    if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and
                        (shhhh.Misc["Check"]["TeamCheck"] == true and (v.Team ~= LocalPlayer.Team) or
                            shhhh.Misc["Check"]["TeamCheck"] ~= true)
                    then
                        local MouseLocation = UIS:GetMouseLocation()
                        local Vector, IsVisible = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                        local Magnitude = (Vector2.new(Vector.X, Vector.Y) - Vector2.new(MouseLocation.X, MouseLocation.Y)).magnitude

                        if Magnitude < Distance and IsVisible and PartVisible(v.Character) then
                            Closest = v
                            Distance = Magnitude
                        end
                    end
                end

                if GameInfo == 2788229376 and shhhh.Misc["Check"]["PlayerKnockCheck"] then
                    if Closest and Closest.Character and not Closest.Character:FindFirstChild("GRABBING_CONSTRAINT") and
                            not Closest.Character:FindFirstChild("BodyEffects")["K.O"].Value
                    then
                            StickyTarget = Closest
                        return Closest
                    end
                    return nil
                end
                
                if GameInfo ~= 2788229376 and shhhh.Misc["Check"]["PlayerKnockCheck"] then
                    if Closest and Closest.Character and Closest.Character.Humanoid.Health > 0 then
                            StickyTarget = Closest
                        return Closest
                    end
                    return nil
                end

                    StickyTarget = Closest
                return Closest
                end
                
                return nil
            end

            local player = game:GetService("Players").LocalPlayer
            local runService = game:GetService("RunService")
            local defaultSpeed = 16
            local isSpeedEnabled = false

            -- Main speed update function
            local function updateSpeed()
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    if isSpeedEnabled and shhhh.WalkSpeed.Options.Enabled then
                        player.Character.Humanoid.WalkSpeed = shhhh.WalkSpeed.Options.Speed
                        print("6443534534534:", shhhh.WalkSpeed.Options.Speed)
                    end
                end
            end

            -- Connect to RenderStepped for continuous updates
            local speedConnection = runService.RenderStepped:Connect(updateSpeed)

            -- Handle character respawning
            player.CharacterAdded:Connect(function(character)
                -- Wait for Humanoid to be available
                character:WaitForChild("Humanoid")
                -- Update speed immediately after respawn
                updateSpeed()
            end)

            -- Handle keybind toggle
            UIS.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode.Name == shhhh.WalkSpeed.Options.Keybind then
                    isSpeedEnabled = not isSpeedEnabled
                    print("x14512:", isSpeedEnabled)
                    
                    if isSpeedEnabled then
                        print("2342323:", shhhh.WalkSpeed.Options.Speed)
                        player.Character.Humanoid.WalkSpeed = shhhh.WalkSpeed.Options.Speed
                        
                        -- Trigger emote when enabling walkspeed
                        if shhhh.WalkSpeed.Options.AutoEmote then
                            local VirtualInputManager = game:GetService("VirtualInputManager")
                            
                            -- Send emote key
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[shhhh.WalkSpeed.Options.EmoteKey], false, game)
                            task.wait(shhhh.WalkSpeed.Options.EmoteDelay)
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[shhhh.WalkSpeed.Options.EmoteKey], false, game)
                            
                            -- Select emote slot
                            task.wait(shhhh.WalkSpeed.Options.EmoteDelay)
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[shhhh.WalkSpeed.Options.EmoteSlot], false, game)
                            task.wait(shhhh.WalkSpeed.Options.EmoteDelay)
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[shhhh.WalkSpeed.Options.EmoteSlot], false, game)
                        end
                    else
                        print("xdef")
                        player.Character.Humanoid.WalkSpeed = defaultSpeed
                    end
                end
            end)

            -- Add toggle handler for silent aim
            UIS.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode.Name == shhhh.Silent.Redirection.Info.Keybind then
                    -- Toggle sticky target on/off
                    if StickyTarget then
                        StickyTarget = nil
                    else
                        -- Find new target when toggling on
                        local MouseLocation = UIS:GetMouseLocation()
                        local Closest = nil
                        local Distance = FOV.Circle.Inline.Radius
                        
                        for i, v in pairs(Players:GetPlayers()) do
                            if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                                local Vector, IsVisible = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                                local Magnitude = (Vector2.new(Vector.X, Vector.Y) - Vector2.new(MouseLocation.X, MouseLocation.Y)).magnitude

                                if Magnitude < Distance and IsVisible and PartVisible(v.Character) then
                                    Closest = v
                                    Distance = Magnitude
                                end
                            end
                        end
                        
                        if Closest then
                            StickyTarget = Closest
                        end
                    end
                end
            end)

            local Meta = getrawmetatable(game)
            local backupindex = Meta.__index
            setreadonly(Meta, false)

            Meta.__index = function(t, k)
                if k:lower() == "hit" and shhhh.Silent.Redirection.Info.Enabled then
                    local TargetPlayer = ClosestToCursor()
                    
                    if TargetPlayer and TargetPlayer.Character then
                        -- Check hit chance
                        local Chance = not shhhh.Silent.Redirection.HitChance.Enabled or 
                                    (shhhh.Silent.Redirection.HitChance.Amount >= math.random(1, 100))
                        
                        if not Chance then
                            return backupindex(t, k)
                        end

                        -- Get target part and validate
                        local Part = TargetPlayer.Character:FindFirstChild(shhhh.Silent["Redirection"]["HitPart"].Target)
                        if not Part then
                            -- Fallback to validated parts if primary target not found
                            for _, validPart in ipairs(shhhh.Silent.Redirection["HitPart"]["Validated Part"]) do
                                Part = TargetPlayer.Character:FindFirstChild(validPart)
                                if Part then break end
                            end
                        end

                        if Part then
                            -- Apply anti-curve to bullet trajectory
                            if shhhh.Silent.Redirection.AntiCurve.Enabled then
                                local AntiCurve = CFrame.Angles(
                                    math.rad(shhhh.Silent.Redirection.AntiCurve.X),
                                    math.rad(shhhh.Silent.Redirection.AntiCurve.Y),
                                    math.rad(shhhh.Silent.Redirection.AntiCurve.Z)
                                )
                                
                                -- Get the direction from camera to target
                                local Direction = (Part.Position - Camera.CFrame.Position).Unit
                                
                                -- Apply anti-curve rotation to the direction
                                Direction = AntiCurve:VectorToWorldSpace(Direction)
                                
                                -- Create a new CFrame at the target position with the adjusted direction
                                return CFrame.new(Part.Position) * CFrame.fromMatrix(Vector3.new(), Direction:Cross(Vector3.new(0, 1, 0)), Vector3.new(0, 1, 0), Direction)
                            else
                                -- Return the part's CFrame directly if anti-curve is disabled
                            return Part.CFrame
                            end
                        end
                    end
                end
                return backupindex(t, k)
            end

            LocalPlayer.Chatted:Connect(
                function(message)
                    if shhhh.ChatCommands.Enabled then
                        local args = string.split(message, " ")
                        if args[1] == shhhh.ChatCommands.Fov and args[2] ~= nil then
                            shhhh.Misc.FOV.Esp.Radius = tonumber(args[2])
                        end

                        if shhhh.ChatCommands.Enabled then
                            local args = string.split(message, " ")
                            if args[1] == shhhh.ChatCommands.Prediction and args[2] ~= nil then
                                shhhh.Silent.Redirection.Prediction.Amount = tonumber(args[2])
                            end
                        end
                    end
                end
            )


            local MouseLoop =
                RunService.Heartbeat:Connect(
                function()
                    local MouseLocation = UIS:GetMouseLocation()

                    -- Only use StickyTarget for visualization
                    if shhhh.Misc.FOV["Esp"]["Control"]["Stick To Target"] and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[shhhh.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)

                        UpdateFOVPosition(Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y))
                    else
                        UpdateFOVPosition(Vector2.new(MouseLocation.X, MouseLocation.Y))
                    end

                    -- Update closest point visualization only for sticky target
                    if shhhh.Misc.FOV.Esp.Control.ShowClosestPoint and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[shhhh.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)
                        local TargetPos = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                        local ClosestPoint = GetClosestPointOnFOV(MouseLocation, TargetPos)
                        
                        FOV.ClosestPoint.Position = ClosestPoint
                        FOV.ClosestPoint.Visible = IsVisible and shhhh.Misc.FOV.Esp.Enabled
                    else
                        FOV.ClosestPoint.Visible = false
                    end

                    -- Tracer Line Logic - only for sticky target
                    if shhhh.Silent.Redirection.Info.Enabled and shhhh.Silent.Redirection.Visualizetarget.Tracer.Enabled and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[shhhh.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)
                        
                        FOV.Line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                        FOV.Line.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                        FOV.Line.Color = shhhh.Silent.Redirection.Visualizetarget.Tracer.Color
                        FOV.Line.Thickness = shhhh.Silent.Redirection.Visualizetarget.Tracer.Thickness
                        FOV.Line.Transparency = shhhh.Silent.Redirection.Visualizetarget.Tracer.Transparency
                        FOV.Line.Visible = true

                        FOV.LineOutline.From = FOV.Line.From
                        FOV.LineOutline.To = FOV.Line.To
                        FOV.LineOutline.Visible = true
                    else
                        FOV.Line.Visible = false
                        FOV.LineOutline.Visible = false
                    end

                    -- Visualize target - only for sticky target
                    if shhhh.Silent.Redirection.Info.Enabled and shhhh.Silent.Redirection.Visualizetarget.Enabled and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[shhhh.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)
                        FOV.MouseLink.Color = shhhh.Silent["Redirection"]
                        FOV.MouseLink.Transparency = 1
                        FOV.MouseLink.Thickness = 0.4
                        FOV.MouseLink.Filled = false
                        FOV.MouseLink.Radius = 20
                        FOV.MouseLink.Visible = true
                        FOV.MouseLink.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                    else
                        FOV.MouseLink.Position = Vector2.new()
                        FOV.MouseLink.Visible = false
                    end
                end
            )

            local function GetClosestPlayer()
                local MaxDist = math.huge
                local Target = nil
                
                for _, v in pairs(Players:GetPlayers()) do
                    if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and 
                    v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild(shhhh.Camlock.HitPart) then
                        local ScreenPos, OnScreen = Camera:WorldToScreenPoint(v.Character[shhhh.Camlock.HitPart].Position)
                        local Distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(ScreenPos.X, ScreenPos.Y)).Magnitude
                        
                        if Distance < MaxDist and OnScreen then
                            MaxDist = Distance
                            Target = v
                        end
                    end
                end
                
                return Target
            end

            local Target
            local Enabled = false
            local Holding = false

            -- Handle both toggle and hold modes for camlock
            UIS.InputBegan:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[shhhh.Camlock.Key] then
                    if shhhh.Camlock.Toggle then
                        Enabled = not Enabled
                        if Enabled then
                            Target = GetClosestPlayer()
                        else
                            Target = nil
                        end
                    else
                        Holding = true
                        Target = GetClosestPlayer()
                    end
                end
                
                if Input.KeyCode == Enum.KeyCode[shhhh.Silent.Redirection.Visualizetarget.Tracer.Key] then
                    shhhh.Silent.Redirection.Visualizetarget.Tracer.Enabled = not shhhh.Silent.Redirection.Visualizetarget.Tracer.Enabled
                end
            end)

            UIS.InputEnded:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[shhhh.Camlock.Key] and not shhhh.Camlock.Toggle then
                    Holding = false
                    Target = nil
                end
            end)

            RunService.RenderStepped:Connect(function()
                if (Enabled or Holding) and Target and Target.Character and Target.Character:FindFirstChild(shhhh.Camlock.HitPart) then
                    local TargetPos = Target.Character[shhhh.Camlock.HitPart].Position
                    
                    if shhhh.Camlock.Prediction.Enabled then
                        local Velocity = Target.Character[shhhh.Camlock.HitPart].Velocity
                        local Distance = (Target.Character[shhhh.Camlock.HitPart].Position - Camera.CFrame.Position).Magnitude
                        local TimeToTarget = Distance / 1000
                        TargetPos = TargetPos + (Velocity * shhhh.Camlock.Prediction.Amount)
                    end
                    
                    if shhhh.Camlock.Shake.Enabled then
                        TargetPos = TargetPos + Vector3.new(
                            math.random(-shhhh.Camlock.Shake.X, shhhh.Camlock.Shake.X) / 100,
                            math.random(-shhhh.Camlock.Shake.Y, shhhh.Camlock.Shake.Y) / 100,
                            math.random(-shhhh.Camlock.Shake.Z, shhhh.Camlock.Shake.Z) / 100
                        )
                    end

                    local CameraPosition = Camera.CFrame.Position
                    local TargetPosition = TargetPos
                    
                    -- Calculate target CFrame with improved aiming
                    local TargetCFrame = CFrame.lookAt(CameraPosition, TargetPosition)
                    
                    -- Smoothly interpolate to target angles with improved logic
                    if shhhh.Camlock.Smoothness.Enabled then
                        local LerpAmount = shhhh.Camlock.Smoothness.Amount
                        
                        if shhhh.Camlock.AimAssist.Enabled then
                            local ScreenPos, OnScreen = Camera:WorldToScreenPoint(TargetPosition)
                            if OnScreen then
                                local ScreenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                                local Distance = (Vector2.new(ScreenPos.X, ScreenPos.Y) - ScreenCenter).Magnitude
                                
                                if Distance < 150 then
                                    LerpAmount = LerpAmount * (1 + shhhh.Camlock.AimAssist.Strength)
                                end
                            end
                        end
                        
                        -- Improved smooth camera movement
                        local CurrentCFrame = Camera.CFrame
                        local NewCFrame = CurrentCFrame:Lerp(TargetCFrame, LerpAmount)
                        
                        -- Apply rotation only, preserve original camera position
                        Camera.CFrame = CFrame.new(CurrentCFrame.Position) * NewCFrame.Rotation
                    else
                        -- Direct camera rotation without changing position
                        Camera.CFrame = CFrame.new(Camera.CFrame.Position) * TargetCFrame.Rotation
                    end
                end
            end)

            -- Add Triggerbot Variables
            local TriggerEnabled = false
            local LastShot = 0
            local TriggerHolding = false

            -- Add Triggerbot Toggle/Hold Handler
            UIS.InputBegan:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[shhhh.Triggerbot.Key] and shhhh.Triggerbot.Enabled then
                    if shhhh.Triggerbot.Hold then
                        TriggerHolding = true
                        TriggerEnabled = true
                    else
                        TriggerEnabled = not TriggerEnabled
                    end
                end
            end)

            UIS.InputEnded:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[shhhh.Triggerbot.Key] and shhhh.Triggerbot.Hold then
                    TriggerHolding = false
                    TriggerEnabled = false
                end
            end)

            -- Add Triggerbot Logic
            RunService.RenderStepped:Connect(function()
                if TriggerEnabled and shhhh.Triggerbot.Enabled and (not shhhh.Triggerbot.Hold or TriggerHolding) then
                    local MouseLocation = UIS:GetMouseLocation()
                    local NearestPlayer = nil
                    local ShortestDistance = shhhh.Triggerbot.Distance

                    for _, Player in pairs(Players:GetPlayers()) do
                        if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                            -- Team Check
                            if shhhh.Triggerbot.CheckTeam and Player.Team == LocalPlayer.Team then
                                continue
                            end

                            -- Knocked Check for Da Hood
                            if shhhh.Triggerbot.CheckKnocked and game.PlaceId == 2788229376 then
                                if Player.Character:FindFirstChild("GRABBING_CONSTRAINT") or 
                                Player.Character:FindFirstChild("BodyEffects")["K.O"].Value then
                                    continue
                                end
                            end

                            local Vector, IsVisible = Camera:WorldToViewportPoint(Player.Character.HumanoidRootPart.Position)
                            if IsVisible then
                                -- Visibility Check
                                if shhhh.Triggerbot.VisibilityCheck then
                                    local Ray = Ray.new(Camera.CFrame.Position, (Player.Character.Head.Position - Camera.CFrame.Position).Unit * 500)
                                    local Hit, Position = workspace:FindPartOnRayWithIgnoreList(Ray, {LocalPlayer.Character, Camera})
                                    
                                    if not Hit or not Hit:IsDescendantOf(Player.Character) then
                                        continue
                                    end
                                end

                                local Distance = (Vector2.new(Vector.X, Vector.Y) - MouseLocation).Magnitude
                                if Distance < ShortestDistance then
                                    ShortestDistance = Distance
                                    NearestPlayer = Player
                                end
                            end
                        end
                    end

                    if NearestPlayer and tick() - LastShot > shhhh.Triggerbot.Delay then
                        mouse1click()
                        LastShot = tick()
                    end
                end
            end)
        end
    )()

    getgenv().Loaded = true